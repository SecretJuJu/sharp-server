name: Deploy to Amazon ECS

on:
  push:
    branches:
      - main
  workflow_dispatch:

env:
  AWS_REGION: ap-northeast-2
  ECR_REPOSITORY: sharp-server
  ECS_CLUSTER: sharp-server-cluster
  ECS_SERVICE: sharp-server-service
  ECS_TASK_DEFINITION: task-definition.json
  CONTAINER_NAME: sharp-server
  ECS_EXECUTION_ROLE_ARN: ""
  ECS_TASK_ROLE_ARN: ""
  LOG_GROUP_NAME: "/ecs/sharp-server"

jobs:
  deploy:
    name: Deploy
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write

    steps:
      - name: Checkout
        uses: actions/checkout@v3

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Create ECR repository if not exists
        run: |
          aws ecr describe-repositories --repository-names ${ECR_REPOSITORY} || aws ecr create-repository --repository-name ${ECR_REPOSITORY}

      - name: Create ECS IAM roles if not exist
        run: |
          # ECS 실행 역할 생성 또는 가져오기
          EXECUTION_ROLE_NAME="ecsTaskExecutionRole"
          EXECUTION_ROLE_ARN=$(aws iam get-role --role-name ${EXECUTION_ROLE_NAME} --query 'Role.Arn' --output text 2>/dev/null || echo "")
          
          if [ -z "$EXECUTION_ROLE_ARN" ]; then
            echo "Creating ECS execution role..."
            EXECUTION_ROLE_ARN=$(aws iam create-role \
              --role-name ${EXECUTION_ROLE_NAME} \
              --assume-role-policy-document '{"Version":"2012-10-17","Statement":[{"Effect":"Allow","Principal":{"Service":"ecs-tasks.amazonaws.com"},"Action":"sts:AssumeRole"}]}' \
              --query 'Role.Arn' --output text)
            
            aws iam attach-role-policy \
              --role-name ${EXECUTION_ROLE_NAME} \
              --policy-arn arn:aws:iam::aws:policy/service-role/AmazonECSTaskExecutionRolePolicy
          fi
          
          # CloudWatch Logs 정책 추가
          aws iam attach-role-policy \
            --role-name ${EXECUTION_ROLE_NAME} \
            --policy-arn arn:aws:iam::aws:policy/CloudWatchLogsFullAccess
          
          # ECS 태스크 역할 생성 또는 가져오기
          TASK_ROLE_NAME="ecsTaskRole"
          TASK_ROLE_ARN=$(aws iam get-role --role-name ${TASK_ROLE_NAME} --query 'Role.Arn' --output text 2>/dev/null || echo "")
          
          if [ -z "$TASK_ROLE_ARN" ]; then
            echo "Creating ECS task role..."
            TASK_ROLE_ARN=$(aws iam create-role \
              --role-name ${TASK_ROLE_NAME} \
              --assume-role-policy-document '{"Version":"2012-10-17","Statement":[{"Effect":"Allow","Principal":{"Service":"ecs-tasks.amazonaws.com"},"Action":"sts:AssumeRole"}]}' \
              --query 'Role.Arn' --output text)
            
            aws iam attach-role-policy \
              --role-name ${TASK_ROLE_NAME} \
              --policy-arn arn:aws:iam::aws:policy/AmazonS3FullAccess
          fi
          
          echo "ECS_EXECUTION_ROLE_ARN=${EXECUTION_ROLE_ARN}" >> $GITHUB_ENV
          echo "ECS_TASK_ROLE_ARN=${TASK_ROLE_ARN}" >> $GITHUB_ENV

      - name: Create ECS cluster
        run: |
          # 클러스터 존재 여부 확인
          CLUSTER_EXISTS=$(aws ecs describe-clusters --clusters ${ECS_CLUSTER} --query 'clusters[0].clusterName' --output text 2>/dev/null || echo "")
          
          if [ "$CLUSTER_EXISTS" == "None" ] || [ -z "$CLUSTER_EXISTS" ]; then
            echo "Creating ECS cluster: ${ECS_CLUSTER}"
            aws ecs create-cluster --cluster-name ${ECS_CLUSTER}
          else
            echo "ECS cluster already exists: ${CLUSTER_EXISTS}"
          fi
          
          # 클러스터가 생성되었는지 확인
          CLUSTER_CHECK=$(aws ecs describe-clusters --clusters ${ECS_CLUSTER} --query 'clusters[0].clusterName' --output text)
          echo "Confirmed ECS cluster: ${CLUSTER_CHECK}"

      - name: Create and verify CloudWatch Logs group
        run: |
          # 로그 그룹 생성 (이미 존재하면 오류 무시)
          aws logs create-log-group --log-group-name ${LOG_GROUP_NAME} || true
          
          # 로그 그룹이 생성되었는지 확인
          LOG_GROUP_CHECK=$(aws logs describe-log-groups --log-group-name-prefix ${LOG_GROUP_NAME} --query 'logGroups[0].logGroupName' --output text)
          
          if [ "$LOG_GROUP_CHECK" == "None" ] || [ -z "$LOG_GROUP_CHECK" ]; then
            echo "Error: Failed to create log group ${LOG_GROUP_NAME}"
            exit 1
          else
            echo "Confirmed log group exists: ${LOG_GROUP_CHECK}"
          fi
          
          # 로그 스트림 생성 (선택 사항이지만 권한 테스트를 위해 추가)
          TEST_STREAM_NAME="github-action-test-$(date +%s)"
          aws logs create-log-stream --log-group-name ${LOG_GROUP_NAME} --log-stream-name ${TEST_STREAM_NAME}
          echo "Created test log stream: ${TEST_STREAM_NAME}"

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v2

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v1

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Build, tag, and push image to Amazon ECR
        id: build-image
        uses: docker/build-push-action@v4
        with:
          context: .
          push: true
          platforms: linux/amd64
          tags: ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:${{ github.sha }}

      - name: Update task definition
        run: |
          # task-definition.json 파일에서 변수 대체
          sed -i "s|\${ECS_EXECUTION_ROLE_ARN}|${ECS_EXECUTION_ROLE_ARN}|g" ${ECS_TASK_DEFINITION}
          sed -i "s|\${ECS_TASK_ROLE_ARN}|${ECS_TASK_ROLE_ARN}|g" ${ECS_TASK_DEFINITION}
          sed -i "s|\${ECR_REPOSITORY_URI}|${{ steps.login-ecr.outputs.registry }}/${ECR_REPOSITORY}|g" ${ECS_TASK_DEFINITION}
          sed -i "s|\${IMAGE_TAG}|${GITHUB_SHA}|g" ${ECS_TASK_DEFINITION}
          sed -i "s|\${AWS_REGION}|${AWS_REGION}|g" ${ECS_TASK_DEFINITION}
          sed -i "s|\${LOG_GROUP_NAME}|${LOG_GROUP_NAME}|g" ${ECS_TASK_DEFINITION}
          
          cat ${ECS_TASK_DEFINITION}

      - name: Register task definition
        id: register-task-def
        run: |
          TASK_DEF_ARN=$(aws ecs register-task-definition --cli-input-json file://${ECS_TASK_DEFINITION} --query 'taskDefinition.taskDefinitionArn' --output text)
          echo "TASK_DEF_ARN=${TASK_DEF_ARN}" >> $GITHUB_ENV
          echo "task-definition-arn=${TASK_DEF_ARN}" >> $GITHUB_OUTPUT

      - name: Get VPC and subnet information
        run: |
          # 기본 VPC와 서브넷 가져오기
          VPC_ID=$(aws ec2 describe-vpcs --filters "Name=isDefault,Values=true" --query 'Vpcs[0].VpcId' --output text)
          SUBNET_IDS=$(aws ec2 describe-subnets --filters "Name=vpc-id,Values=${VPC_ID}" --query 'Subnets[?MapPublicIpOnLaunch==`true`].SubnetId' --output text | tr '\t' ',')
          
          echo "Using VPC: ${VPC_ID}"
          echo "Using Subnets: ${SUBNET_IDS}"
          echo "VPC_ID=${VPC_ID}" >> $GITHUB_ENV
          echo "SUBNET_IDS=${SUBNET_IDS}" >> $GITHUB_ENV
          
          # 보안 그룹 생성 또는 가져오기
          SG_NAME="ecs-sharp-server-sg"
          SG_ID=$(aws ec2 describe-security-groups --filters "Name=group-name,Values=${SG_NAME}" --query 'SecurityGroups[0].GroupId' --output text 2>/dev/null || echo "")
          
          if [ -z "$SG_ID" ] || [ "$SG_ID" == "None" ]; then
            echo "Creating security group..."
            SG_ID=$(aws ec2 create-security-group --group-name ${SG_NAME} --description "Security group for Sharp Server ECS service" --vpc-id ${VPC_ID} --query 'GroupId' --output text)
            
            # 인바운드 규칙 추가
            aws ec2 authorize-security-group-ingress --group-id ${SG_ID} --protocol tcp --port 3000 --cidr 0.0.0.0/0
          fi
          
          echo "Using Security Group: ${SG_ID}"
          echo "SG_ID=${SG_ID}" >> $GITHUB_ENV

      - name: Create or update Network Load Balancer
        run: |
          # NLB 이름 및 대상 그룹 이름 설정
          NLB_NAME="sharp-server-nlb"
          TG_NAME="sharp-server-tg"
          
          # 서브넷 ID 가져오기
          SUBNET_IDS_ARRAY=($(echo ${SUBNET_IDS} | tr ',' ' '))
          SUBNET_LIST=""
          for subnet in "${SUBNET_IDS_ARRAY[@]}"; do
            SUBNET_LIST="${SUBNET_LIST} SubnetId=${subnet}"
          done
          SUBNET_LIST=$(echo ${SUBNET_LIST} | xargs)
          
          # NLB 존재 여부 확인
          NLB_ARN=$(aws elbv2 describe-load-balancers --names ${NLB_NAME} --query 'LoadBalancers[0].LoadBalancerArn' --output text 2>/dev/null || echo "")
          
          # NLB 생성 또는 업데이트
          if [ -z "$NLB_ARN" ] || [ "$NLB_ARN" == "None" ]; then
            echo "Creating new Network Load Balancer..."
            NLB_ARN=$(aws elbv2 create-load-balancer \
              --name ${NLB_NAME} \
              --type network \
              --subnets ${SUBNET_LIST} \
              --query 'LoadBalancers[0].LoadBalancerArn' --output text)
            
            echo "Created Load Balancer: ${NLB_ARN}"
          else
            echo "Load Balancer already exists: ${NLB_ARN}"
          fi
          
          # 대상 그룹 존재 여부 확인
          TG_ARN=$(aws elbv2 describe-target-groups --names ${TG_NAME} --query 'TargetGroups[0].TargetGroupArn' --output text 2>/dev/null || echo "")
          
          # 대상 그룹 생성 또는 업데이트
          if [ -z "$TG_ARN" ] || [ "$TG_ARN" == "None" ]; then
            echo "Creating new Target Group..."
            TG_ARN=$(aws elbv2 create-target-group \
              --name ${TG_NAME} \
              --protocol TCP \
              --port 3000 \
              --vpc-id ${VPC_ID} \
              --target-type ip \
              --health-check-protocol HTTP \
              --health-check-path "/" \
              --health-check-interval-seconds 30 \
              --health-check-timeout-seconds 10 \
              --healthy-threshold-count 3 \
              --unhealthy-threshold-count 3 \
              --query 'TargetGroups[0].TargetGroupArn' --output text)
            
            echo "Created Target Group: ${TG_ARN}"
          else
            echo "Target Group already exists: ${TG_ARN}"
          fi
          
          # 리스너 존재 여부 확인
          LISTENER_ARN=$(aws elbv2 describe-listeners --load-balancer-arn ${NLB_ARN} --query 'Listeners[0].ListenerArn' --output text 2>/dev/null || echo "")
          
          # 리스너 생성 또는 업데이트
          if [ -z "$LISTENER_ARN" ] || [ "$LISTENER_ARN" == "None" ]; then
            echo "Creating new Listener..."
            LISTENER_ARN=$(aws elbv2 create-listener \
              --load-balancer-arn ${NLB_ARN} \
              --protocol TCP \
              --port 80 \
              --default-actions Type=forward,TargetGroupArn=${TG_ARN} \
              --query 'Listeners[0].ListenerArn' --output text)
            
            echo "Created Listener: ${LISTENER_ARN}"
          else
            echo "Listener already exists: ${LISTENER_ARN}"
          fi
          
          # NLB DNS 이름 가져오기
          NLB_DNS=$(aws elbv2 describe-load-balancers --load-balancer-arns ${NLB_ARN} --query 'LoadBalancers[0].DNSName' --output text)
          echo "NLB_DNS=${NLB_DNS}" >> $GITHUB_ENV
          echo "TG_ARN=${TG_ARN}" >> $GITHUB_ENV
          
          echo "Network Load Balancer DNS: ${NLB_DNS}"
          echo "For Cloudflare, create a CNAME record pointing to: ${NLB_DNS}"

      - name: Create or update ECS service
        run: |
          # 클러스터 존재 여부 다시 확인
          CLUSTER_EXISTS=$(aws ecs describe-clusters --clusters ${ECS_CLUSTER} --query 'clusters[0].clusterName' --output text 2>/dev/null || echo "")
          
          if [ "$CLUSTER_EXISTS" == "None" ] || [ -z "$CLUSTER_EXISTS" ]; then
            echo "Error: ECS cluster ${ECS_CLUSTER} does not exist. Creating it now..."
            aws ecs create-cluster --cluster-name ${ECS_CLUSTER}
          fi
          
          # 서비스 상태 확인 및 처리
          SERVICE_STATUS=$(aws ecs describe-services --cluster ${ECS_CLUSTER} --services ${ECS_SERVICE} --query 'services[0].status' --output text 2>/dev/null || echo "INACTIVE")
          
          echo "Current service status: ${SERVICE_STATUS}"
          
          # 서비스가 존재하고 ACTIVE 상태인 경우에만 업데이트 또는 삭제 시도
          if [ "$SERVICE_STATUS" == "ACTIVE" ]; then
            echo "Stopping existing ECS service..."
            aws ecs update-service --cluster ${ECS_CLUSTER} --service ${ECS_SERVICE} --desired-count 0 || true
            
            echo "Waiting for tasks to stop..."
            sleep 10
            
            echo "Deleting existing ECS service..."
            aws ecs delete-service --cluster ${ECS_CLUSTER} --service ${ECS_SERVICE} --force || true
            
            # 서비스가 삭제될 때까지 대기
            echo "Waiting for service to be deleted..."
            sleep 30
          elif [ "$SERVICE_STATUS" != "INACTIVE" ] && [ "$SERVICE_STATUS" != "None" ]; then
            echo "Service is in ${SERVICE_STATUS} state. Waiting for it to complete..."
            sleep 60
          fi
          
          # 서비스가 존재하는지 다시 확인
          SERVICE_EXISTS=$(aws ecs describe-services --cluster ${ECS_CLUSTER} --services ${ECS_SERVICE} --query 'services[0].status' --output text 2>/dev/null || echo "INACTIVE")
          
          if [ "$SERVICE_EXISTS" != "INACTIVE" ] && [ "$SERVICE_EXISTS" != "None" ]; then
            echo "Service still exists in ${SERVICE_EXISTS} state. Trying to force delete..."
            aws ecs delete-service --cluster ${ECS_CLUSTER} --service ${ECS_SERVICE} --force || true
            sleep 60
          fi
          
          # 새 서비스 생성 (로드 밸런서와 연결)
          echo "Creating new ECS service with load balancer..."
          aws ecs create-service \
            --cluster ${ECS_CLUSTER} \
            --service-name ${ECS_SERVICE} \
            --task-definition ${TASK_DEF_ARN} \
            --desired-count 1 \
            --launch-type FARGATE \
            --network-configuration "awsvpcConfiguration={subnets=[${SUBNET_IDS}],securityGroups=[${SG_ID}],assignPublicIp=ENABLED}" \
            --load-balancers "targetGroupArn=${TG_ARN},containerName=${CONTAINER_NAME},containerPort=3000" \
            --scheduling-strategy REPLICA
          
          # 서비스 안정화 대기
          echo "Waiting for service to stabilize..."
          aws ecs wait services-stable --cluster ${ECS_CLUSTER} --services ${ECS_SERVICE} || true

      - name: Get service details
        if: success()
        run: |
          # 서비스 세부 정보 가져오기
          TASK_ARN=$(aws ecs list-tasks --cluster ${ECS_CLUSTER} --service-name ${ECS_SERVICE} --query 'taskArns[0]' --output text)
          
          if [ ! -z "$TASK_ARN" ] && [ "$TASK_ARN" != "None" ]; then
            echo "Task ARN: ${TASK_ARN}"
            
            # 태스크 상태 확인
            TASK_STATUS=$(aws ecs describe-tasks --cluster ${ECS_CLUSTER} --tasks ${TASK_ARN} --query 'tasks[0].lastStatus' --output text)
            echo "Task Status: ${TASK_STATUS}"
            
            # 태스크 실패 이유 확인
            TASK_STOPPED_REASON=$(aws ecs describe-tasks --cluster ${ECS_CLUSTER} --tasks ${TASK_ARN} --query 'tasks[0].stoppedReason' --output text)
            if [ ! -z "$TASK_STOPPED_REASON" ] && [ "$TASK_STOPPED_REASON" != "None" ]; then
              echo "Task Stopped Reason: ${TASK_STOPPED_REASON}"
            fi
            
            # 컨테이너 상태 확인
            CONTAINER_STATUS=$(aws ecs describe-tasks --cluster ${ECS_CLUSTER} --tasks ${TASK_ARN} --query 'tasks[0].containers[0].lastStatus' --output text)
            echo "Container Status: ${CONTAINER_STATUS}"
            
            # 컨테이너 실패 이유 확인
            CONTAINER_REASON=$(aws ecs describe-tasks --cluster ${ECS_CLUSTER} --tasks ${TASK_ARN} --query 'tasks[0].containers[0].reason' --output text)
            if [ ! -z "$CONTAINER_REASON" ] && [ "$CONTAINER_REASON" != "None" ]; then
              echo "Container Reason: ${CONTAINER_REASON}"
            fi
            
            # 네트워크 인터페이스 확인
            ENI_ID=$(aws ecs describe-tasks --cluster ${ECS_CLUSTER} --tasks ${TASK_ARN} --query 'tasks[0].attachments[0].details[?name==`networkInterfaceId`].value' --output text)
            
            if [ ! -z "$ENI_ID" ] && [ "$ENI_ID" != "None" ]; then
              PUBLIC_IP=$(aws ec2 describe-network-interfaces --network-interface-ids ${ENI_ID} --query 'NetworkInterfaces[0].Association.PublicIp' --output text)
              echo "Service is running at: http://${PUBLIC_IP}:3000"
            else
              echo "Could not find network interface for task"
            fi
          else
            echo "No tasks found for service"
          fi
          
          # NLB DNS 정보 출력
          if [ ! -z "$NLB_DNS" ]; then
            echo "Service is accessible via Network Load Balancer: http://${NLB_DNS}"
            echo "For Cloudflare, create a CNAME record pointing to: ${NLB_DNS}"
          fi

      - name: Post-deployment notification
        if: success()
        run: |
          echo "Deployment to ECS completed successfully!" 